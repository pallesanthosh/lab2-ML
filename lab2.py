# -*- coding: utf-8 -*-
"""lab2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1UM43yaPr7wcBSV2q0Vt5jqokoOxhw2IM
"""

import math

def cal_euclidean_distance(vec1, vec2):
    assert len(vec1) == len(vec2)
    squared_diff_sum = sum((x - y) ** 2 for x, y in zip(vec1, vec2))
    distance = math.sqrt(squared_diff_sum)
    return distance

def cal_manhattan_distance(vec1, vec2):
    assert len(vec1) == len(vec2)
    abs_diff_sum = sum(abs(x - y) for x, y in zip(vec1, vec2))
    return abs_diff_sum

def main():
    # Input vectors manually with new prompts
    vector_x = list(map(int, input("Enter the first vector (space-separated values): ").split()))
    vector_y = list(map(int, input("Enter the second vector (space-separated values): ").split()))

    # Calculate distances
    euclidean_result = cal_euclidean_distance(vector_x, vector_y)
    manhattan_result = cal_manhattan_distance(vector_x, vector_y)

    # Print the results
    print(f"Euclidean Distance: {euclidean_result}")
    print(f"Manhattan Distance: {manhattan_result}")

# Call the main function
main()

import math

def calculate_distance(vec1, vec2):
    assert len(vec1) == len(vec2)
    squared_diff_sum = sum((x - y) ** 2 for x, y in zip(vec1, vec2))
    distance = math.sqrt(squared_diff_sum)
    return distance

def find_neighbors(training_data, test_instance, k):
    distances = [(calculate_distance(test_instance, data_point[0]), data_point[1]) for data_point in training_data]
    sorted_distances = sorted(distances, key=lambda x: x[0])[:k]
    neighbors = [(distance, label) for distance, label in sorted_distances]
    return neighbors

def classify_k(training_data, test_instance, k):
    neighbors = find_neighbors(training_data, test_instance, k)
    labels = [label for _, label in neighbors]
    predicted_label = max(set(labels), key=labels.count)
    return predicted_label

def main():
    training_data = [([1, 2], 'A'), ([2, 3], 'A'), ([5, 5], 'B'), ([6, 7], 'B')]
    test_instance = [3, 4]
    k = 3

    predicted_label = classify_k(training_data, test_instance, k)

    print(f"Predicted Label: {predicted_label}")

# Call the main function
main()

import numpy as np

def encode_categorical_data(input_data, target_column):
    unique_labels = list(set(input_data[:, target_column]))

    label_mapping = {label: index for index, label in enumerate(unique_labels)}

    encoded_column = [label_mapping[label] for label in input_data[:, target_column]]

    encoded_data = input_data.copy()
    encoded_data[:, target_column] = encoded_column

    return encoded_data, label_mapping

def main():
    product_dataset = np.array([
        ['Small', 20, 'Electronics'],
        ['Medium', 50, 'Clothing'],
        ['Large', 120, 'Electronics'],
        ['Medium', 30, 'Books'],
        ['Small', 15, 'Clothing'],
    ])

    category_column_index = 2

    encoded_dataset, label_mapping = encode_categorical_data(product_dataset, category_column_index)

    print("Original Product Dataset:")
    for row in product_dataset:
        print(row)

    print("\nEncoded Product Dataset:")
    for row in encoded_dataset:
        print(row)

    print("\nLabel Mapping for Categories:")
    print(label_mapping)

# Call the main function
main()

def one_hot_encode(data, col_index):
    labels = list(set(row[col_index] for row in data))

    label_mapping = {label: [0] * len(labels) for label in labels}

    for i, label in enumerate(labels):
        for row in data:
            if row[col_index] == label:
                label_mapping[label][i] = 1

    one_hot_encoded_data = [
        row[:col_index] + label_mapping[row[col_index]] + row[col_index + 1:]
        for row in data
    ]

    return one_hot_encoded_data

def process_data():
    dataset = [
        ['Small', 25, 'TypeA'],
        ['Medium', 30, 'TypeB'],
        ['Large', 22, 'TypeA'],
        ['Medium', 28, 'TypeC'],
    ]

    col_index = 2

    one_hot_encoded_dataset = one_hot_encode(dataset, col_index)

    print("Original Data:")
    for row in dataset:
        print(row)

    print("\nOne-Hot Encoded Data:")
    for row in one_hot_encoded_dataset:
        print(row)

# Call the main function
process_data()